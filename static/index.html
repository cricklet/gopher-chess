<style>
    @media (prefers-color-scheme: dark) {
        body {
            background-color: #333;
        }

        .dark {
            background-color: #555;
        }

        .light {
            background-color: #777;
        }

        .piece.white {
            filter: invert(80%);
        }
        #logs {
            color: #eee;
        }
    }

    @media (prefers-color-scheme: light) {
        body {
            background-color: #eee;
        }

        .dark {
            background-color: #777;
        }

        .light {
            background-color: #aaa;
        }

        .piece.white {
            filter: invert(90%);
        }
    }

    * {
        box-sizing: border-box;
    }

    body {
        display: flex;
        align-items: center;
        flex-direction: column;
        height: 100%;
    }

    #container {
        display: flex;
        height: 100%;
        width: 100%;
        align-items: center;
        flex-direction: row;
        padding: 20px;
    }

    #board {
        width:fit-content;
        height: 100%;
        display: flex;
        flex-direction:column;
        justify-content:center;
        align-items:center;
    }
    #sidepanel {
        flex: 1;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: end;
    }
    #logs {
        display: flex;
        align-items:flex-start;
        flex-direction: column-reverse;
        padding: 20px 20px 4px 20px;
        font-family:monospace;
        overflow:scroll;
    }
    #input {
        margin: 0px 20px 20px 20px;
        font-family:monospace;
    }

    .row {
        font-size:calc(2em + 2vw);
        display: flex;
    }

    .square {
        cursor: default;
        display: grid;
        width: 1em;
        height: 1em;
        line-height: 1em;
    }

    span {
        display: inline-block;
        text-align: center;
        grid-area: 1/1;
    }

    .backdrop {
        width: 1em;
        height: 1em;
    }

    .backdrop.selected:hover {
        cursor: pointer;
        backdrop-filter: sepia(50%) saturate(100%) hue-rotate(180deg);
        -webkit-backdrop-filter: sepia(50%) saturate(100%) hue-rotate(180deg);
    }

    .backdrop.potential:hover {
        cursor: pointer;
        backdrop-filter: sepia(50%) saturate(100%) hue-rotate(180deg);
        -webkit-backdrop-filter: sepia(50%) saturate(100%) hue-rotate(180deg);
    }

    .backdrop.selectable:hover {
        cursor: pointer;
        backdrop-filter: sepia(50%) saturate(100%) hue-rotate(180deg);
        -webkit-backdrop-filter: sepia(50%) saturate(100%) hue-rotate(180deg);
    }

    .potentialCircle {
        z-index: 9;
        pointer-events: none;
    }

    .potentialCircle.white {
        filter: invert(90%);
    }

    .potentialCircle::after {
        content: "â¬¤";
        font-size: 0.4em;
    }


    .piece {
        width: 1em;
        height: 1em;
        background-origin: content-box;
        background-repeat: no-repeat;
        background-position: center;
        padding: 4px;
        box-sizing: border-box;
        stroke: #646464;
        stroke-width: 1px;
        pointer-events: none;
    }

    .rook {
        background-image: url('/static/chess-rook-solid.svg');
    }

    .king {
        background-image: url('/static/chess-king-solid.svg');
    }

    .knight {
        background-image: url('/static/chess-knight-solid.svg');
    }

    .pawn {
        background-image: url('/static/chess-pawn-solid.svg');
    }

    .queen {
        background-image: url('/static/chess-queen-solid.svg');
    }

    .bishop {
        background-image: url('/static/chess-bishop-solid.svg');
    }
</style>
<script>
    PIECE_CLASS_MAP = {
        'r': ['black', 'rook'],
        'n': ['black', 'knight'],
        'b': ['black', 'bishop'],
        'q': ['black', 'queen'],
        'k': ['black', 'king'],
        'p': ['black', 'pawn'],
        'R': ['white', 'rook'],
        'N': ['white', 'knight'],
        'B': ['white', 'bishop'],
        'Q': ['white', 'queen'],
        'K': ['white', 'king'],
        'P': ['white', 'pawn'],
    }

    PLAYER_PIECE_MAP = {
        'white': new Set(['R', 'N', 'B', 'Q', 'K', 'P']),
        'black': new Set(['r', 'n', 'b', 'q', 'k', 'p'])
    }

    START_POS_FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"

    function rankFromChar(c) {
        return parseInt(c) - 1
    }

    function fileFromChar(c) {
        return ["a", "b", "c", "d", "e", "f", "g", "h",].indexOf(c)
    }

    function fileRankMatches(file, rank, location) {
        if (!location) {
            return false
        }
        return file == location[0] && rank == location[1]
    }


    function fileRankFromString(location) {
        return [fileFromChar(location[0]), rankFromChar(location[1])]
    }

    function fileRankToString(file, rank) {
        return ["a", "b", "c", "d", "e", "f", "g", "h",][file] + (rank + 1)
    }

    function parseFenBoardString(fen) {
        let board = [
            [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
            [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
            [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
            [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
            [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
            [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
            [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
            [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']
        ]
        let boardFen = fen.split(' ')[0]
        let rankIndex = 7
        let fileIndex = 0
        for (let c of boardFen) {
            if (c == '/') {
                if (fileIndex != 8) {
                    throw Error("couldn't parse " + boardFen)
                }
                rankIndex--
                fileIndex = 0
                continue
            }
            indicesToSkip = parseInt(c)
            if (!isNaN(indicesToSkip)) {
                fileIndex += indicesToSkip
                continue
            }
            board[fileIndex][rankIndex] = c
            fileIndex++
        }

        return board
    }

    let board, selectedFileRank, player, availableMoves

    async function update() {
        function click(file, rank) {
            const c = board[file][rank]
            if (availableMoves && availableMoves[file] && availableMoves[file][rank]) {
                send({
                    Move: fileRankToString(...selectedFileRank) + fileRankToString(file, rank)
                })
                return
            }

            if (c != " " && PLAYER_PIECE_MAP[player].has(c)) {
                if (!fileRankMatches(file, rank, selectedFileRank)) {
                    send({
                        Selection: fileRankToString(file, rank)
                    })
                    return
                }
            }
            send({
                Selection: ""
            })
        }

        const boardEl = document.getElementById('board')
        boardEl.innerHTML = ''

        for (let rank = 7; rank >= 0; rank--) {
            const rowEl = document.createElement('div')
            rowEl.classList.add('row')
            boardEl.appendChild(rowEl)

            for (let file = 0; file < 8; file++) {
                const c = board[file][rank]
                const spanEl = document.createElement('span')
                spanEl.classList.add('square')

                if ((file + rank) % 2 == 1) spanEl.classList.add('dark')
                else spanEl.classList.add('light')

                spanEl.onclick = () => click(file, rank)

                if (selectedFileRank && selectedFileRank[0] == file && selectedFileRank[1] == rank) {
                    const backdropEl = document.createElement('span')
                    backdropEl.classList.add('selected')
                    backdropEl.classList.add('backdrop')
                    spanEl.appendChild(backdropEl)
                }

                const pieceClasses = PIECE_CLASS_MAP[c]
                if (pieceClasses) {
                    if (PLAYER_PIECE_MAP[player].has(c) && selectedFileRank == null) {
                        const backdropEl = document.createElement('span')
                        backdropEl.classList.add('selectable')
                        backdropEl.classList.add('backdrop')
                        spanEl.appendChild(backdropEl)
                    }

                    const pieceEl = document.createElement('span')
                    for (const c of pieceClasses) {
                        pieceEl.classList.add(c)
                    }
                    pieceEl.classList.add('piece')
                    spanEl.appendChild(pieceEl)
                }
                if (availableMoves && availableMoves[file] && availableMoves[file][rank]) {
                    const backdropEl = document.createElement('span')
                    backdropEl.classList.add('potential')
                    backdropEl.classList.add('backdrop')
                    spanEl.appendChild(backdropEl)

                    const potentialCircle = document.createElement('span')
                    potentialCircle.classList.add('potentialCircle')
                    potentialCircle.classList.add(player)
                    spanEl.appendChild(potentialCircle)

                    spanEl.classList.add('potential')
                }
                rowEl.appendChild(spanEl)
            }
        }
    }

    let socket = new WebSocket("ws://0.0.0.0:8002/ws");

    function send(obj) {
        const message = JSON.stringify(obj)
        log("sending", message)
        socket.send(message)
    }

    function log(... values) {
        console.log(...values)
        const textEl = document.createElement('div')
        textEl.innerText = values.map(v =>
            JSON.stringify(v)
            .replaceAll("\"", "'")
            .replaceAll("\\n", "")
            .replace(/^'+|'+$/g, '')
            .replaceAll("\\", "")).join(" ")
        document.getElementById("logs").prepend(textEl)
    }

    function urlFromFen(fen) {
        return "/fen/" + fen
    }
    function urlPath() {
        return decodeURI(window.location.pathname)
    }
    function updateUrlForFen(fenString) {
        if (!fenString) {
            return
        }
        const fenUrl = urlFromFen(fenString)
        if (urlPath() === "/" && fenUrl === urlFromFen(START_POS_FEN)) {
            return
        }
        if (urlPath() !== fenUrl) {
            window.history.pushState(null, "", fenUrl) 
        }
        return
    }

    document.addEventListener("DOMContentLoaded", () => {
        socket.onopen = () => {
            let fen = decodeURI(urlPath().slice(1).replace("fen/", ""))
            if (fen == 'startpos' || fen.length < 1) {
                fen = START_POS_FEN
            }
            send({ NewFen: fen })
        };
        window.addEventListener('popstate', function (event) {
            let fen = decodeURI(window.location.pathname.slice(1).replace("fen/", ""))
            if (fen == 'startpos' || fen.length < 1) {
                fen = START_POS_FEN
            }
            send({ NewFen: fen })
        });
        socket.onmessage = event => {
            data = JSON.parse(event.data)
            if (Array.isArray(data)) {
                for (const line of data) {
                    log(">",line)
                }
            } else {
                log('received', data)
                board = parseFenBoardString(data.FenString)

                updateUrlForFen(data.FenString)

                selectedFileRank = data.Selection ? fileRankFromString(data.Selection) : null

                let availableMovesArray = data.PossibleMoves ? data.PossibleMoves.map(v => fileRankFromString(v)) : null
                availableMoves = {}
                for (const [file, rank] of availableMovesArray || []) {
                    if (!availableMoves[file]) {
                        availableMoves[file] = {}
                    }
                    availableMoves[file][rank] = true
                }

                player = data.Player

                update()
            }
        }

        socket.onclose = event => {
        };

        socket.onerror = error => {
            log("Socket Error: ", error);
        };
    })
</script>
<div id="container">
    <div id="board"></div>
    <div id="sidepanel">
        <div id="logs"></div>
        <input id="input" autofocus="true"/>
    </div>
</div>